/**
 * @file vl53l8cx_uld_platform.c
 * @brief VL53L8CX Platform Abstraction Layer Implementation
 * 
 * This file contains implementations of the platform abstraction
 * layer for the VL53L8CX.
 * 
 * @author WilliTourt willitourt@foxmail.com
 * @version 1.1
 * @date 2026.02.23
 * 
 * @note Comments are mostly generated by AI
 * 
 * @changelog:
 * - (See header file for changes)
 */


#include "vl53l8cx_uld_platform.h"

/**
 * @brief Read a single byte from VL53L8CX sensor register
 * 
 * This function reads one byte from the specified register address of the
 * VL53L8CX sensor using either I2C or SPI communication based on the
 * platform configuration.
 * 
 * @param p_platform Pointer to VL53L8CX platform structure
 * @param RegisterAdress 16-bit register address to read from
 * @param p_value Pointer to store the read byte value
 * @return uint8_t Status code (VL53L8CX_PLATFORM_OK on success)
 */
uint8_t VL53L8CX_RdByte(VL53L8CX_Platform *p_platform, uint16_t RegisterAdress, uint8_t *p_value) {

	/* Parameter validation */
	if (p_platform == NULL || p_value == NULL) return VL53L8CX_PLATFORM_INVALID_PARAM;

	/* Select communication interface */
	switch (p_platform->comms_type) {
		case VL53L8CX_COMMS_I2C: {
		#if defined(HAL_I2C_MODULE_ENABLED)

			HAL_StatusTypeDef hal_ret = HAL_I2C_Mem_Read(p_platform->hi2c,
							p_platform->i2c_addr,
							RegisterAdress,
							I2C_MEMADD_SIZE_16BIT,
							p_value,
							1,
							VL53L8CX_COMM_TIMEOUT_MS);

			if (hal_ret == HAL_OK) { return VL53L8CX_PLATFORM_OK; }
			else if (hal_ret == HAL_TIMEOUT) { return VL53L8CX_PLATFORM_TIMEOUT_ERROR; }
			else { return VL53L8CX_PLATFORM_STATUS_ERROR; }
		
		#else
			return VL53L8CX_PLATFORM_INVALID_PARAM;
		#endif
		}

		case VL53L8CX_COMMS_SPI: {
		#if defined(HAL_SPI_MODULE_ENABLED)

			HAL_StatusTypeDef hal_ret;
			if (p_platform->hspi == NULL || p_platform->cs_port == NULL) return VL53L8CX_PLATFORM_INVALID_PARAM;

			uint8_t addr_buf[2];
			addr_buf[0] = (uint8_t)((RegisterAdress >> 8) & 0xFF);
			addr_buf[1] = (uint8_t)(RegisterAdress & 0xFF);

			HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_RESET);
			hal_ret = HAL_SPI_Transmit(p_platform->hspi, addr_buf, 2, VL53L8CX_COMM_TIMEOUT_MS);
			if (hal_ret != HAL_OK) {
				HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_SET);
				return (hal_ret == HAL_TIMEOUT) ? VL53L8CX_PLATFORM_TIMEOUT_ERROR : VL53L8CX_PLATFORM_STATUS_ERROR;
			}

			hal_ret = HAL_SPI_Receive(p_platform->hspi, p_value, 1, VL53L8CX_COMM_TIMEOUT_MS);
			HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_SET);

			if (hal_ret == HAL_OK) return VL53L8CX_PLATFORM_OK;
			if (hal_ret == HAL_TIMEOUT) return VL53L8CX_PLATFORM_TIMEOUT_ERROR;
			return VL53L8CX_PLATFORM_STATUS_ERROR;
		
		#else
			return VL53L8CX_PLATFORM_INVALID_PARAM;
		#endif
		}

		default: return VL53L8CX_PLATFORM_INVALID_PARAM;
	}

}

/**
 * @brief Write a single byte to VL53L8CX sensor register
 * 
 * This function writes one byte to the specified register address of the
 * VL53L8CX sensor using either I2C or SPI communication based on the
 * platform configuration.
 * 
 * @param p_platform Pointer to VL53L8CX platform structure
 * @param RegisterAdress 16-bit register address to write to
 * @param value Byte value to write
 * @return uint8_t Status code (VL53L8CX_PLATFORM_OK on success)
 */
uint8_t VL53L8CX_WrByte(VL53L8CX_Platform *p_platform, uint16_t RegisterAdress, uint8_t value) {

	/* Parameter validation */
	if (p_platform == NULL) {
		return VL53L8CX_PLATFORM_INVALID_PARAM;
	}

	/* Select communication interface */
	switch (p_platform->comms_type) {
		case VL53L8CX_COMMS_I2C: {
		#if defined(HAL_I2C_MODULE_ENABLED)
		
			HAL_StatusTypeDef hal_ret = HAL_I2C_Mem_Write(p_platform->hi2c,
							 							  p_platform->i2c_addr,
							 							  RegisterAdress,
							 							  I2C_MEMADD_SIZE_16BIT,
							 							  &value,
							 							  1,
							 							  VL53L8CX_COMM_TIMEOUT_MS);

			if (hal_ret == HAL_OK) { return VL53L8CX_PLATFORM_OK; }
			else if (hal_ret == HAL_TIMEOUT) { return VL53L8CX_PLATFORM_TIMEOUT_ERROR; }
			else { return VL53L8CX_PLATFORM_STATUS_ERROR; }
		
		#else
			return VL53L8CX_PLATFORM_INVALID_PARAM;
		#endif
		}

		case VL53L8CX_COMMS_SPI: {
		#if defined(HAL_SPI_MODULE_ENABLED)
		
			HAL_StatusTypeDef hal_ret;
			if (p_platform->hspi == NULL || p_platform->cs_port == NULL) return VL53L8CX_PLATFORM_INVALID_PARAM;

			uint8_t addr_buf[2];
			addr_buf[0] = (uint8_t)((RegisterAdress >> 8) & 0xFF);
			addr_buf[1] = (uint8_t)(RegisterAdress & 0xFF);

			HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_RESET);
			hal_ret = HAL_SPI_Transmit(p_platform->hspi, addr_buf, 2, VL53L8CX_COMM_TIMEOUT_MS);
			if (hal_ret != HAL_OK) {
				HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_SET);
				return (hal_ret == HAL_TIMEOUT) ? VL53L8CX_PLATFORM_TIMEOUT_ERROR : VL53L8CX_PLATFORM_STATUS_ERROR;
			}

			hal_ret = HAL_SPI_Transmit(p_platform->hspi, &value, 1, VL53L8CX_COMM_TIMEOUT_MS);
			HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_SET);

			if (hal_ret == HAL_OK) return VL53L8CX_PLATFORM_OK;
			if (hal_ret == HAL_TIMEOUT) return VL53L8CX_PLATFORM_TIMEOUT_ERROR;
			return VL53L8CX_PLATFORM_STATUS_ERROR;
		
		#else
			return VL53L8CX_PLATFORM_INVALID_PARAM;
		#endif
		}

		default: return VL53L8CX_PLATFORM_INVALID_PARAM;
	}

}

/**
 * @brief Write multiple bytes to VL53L8CX sensor registers
 * 
 * This function writes multiple bytes to the specified register address of the
 * VL53L8CX sensor using either I2C or SPI communication based on the
 * platform configuration. The data is written sequentially starting from the
 * specified register address.
 * 
 * @param p_platform Pointer to VL53L8CX platform structure
 * @param RegisterAdress 16-bit starting register address to write to
 * @param p_values Pointer to buffer containing bytes to write
 * @param size Number of bytes to write
 * @return uint8_t Status code (VL53L8CX_PLATFORM_OK on success)
 */
uint8_t VL53L8CX_WrMulti(VL53L8CX_Platform *p_platform, uint16_t RegisterAdress, uint8_t *p_values, uint32_t size) {

	/* Parameter validation */
	if (p_platform == NULL || p_values == NULL || size == 0) {
		return VL53L8CX_PLATFORM_INVALID_PARAM;
	}

	/* Select communication interface */
	switch (p_platform->comms_type) {
		case VL53L8CX_COMMS_I2C: {
		#if defined(HAL_I2C_MODULE_ENABLED)
		
			HAL_StatusTypeDef hal_ret = HAL_I2C_Mem_Write(p_platform->hi2c,
							 p_platform->i2c_addr,
							 RegisterAdress,
							 I2C_MEMADD_SIZE_16BIT,
							 p_values,
							 (uint16_t)size,
							 VL53L8CX_COMM_TIMEOUT_MS);

			if (hal_ret == HAL_OK) { return VL53L8CX_PLATFORM_OK; }
			else if (hal_ret == HAL_TIMEOUT) { return VL53L8CX_PLATFORM_TIMEOUT_ERROR; }
			else { return VL53L8CX_PLATFORM_STATUS_ERROR; }
		
		#else
			return VL53L8CX_PLATFORM_INVALID_PARAM;
		#endif
		}

		case VL53L8CX_COMMS_SPI: {
		#if defined(HAL_SPI_MODULE_ENABLED)
		
			HAL_StatusTypeDef hal_ret;
			if (p_platform->hspi == NULL || p_platform->cs_port == NULL) return VL53L8CX_PLATFORM_INVALID_PARAM;

			uint8_t addr_buf[2];
			addr_buf[0] = (uint8_t)((RegisterAdress >> 8) & 0xFF);
			addr_buf[1] = (uint8_t)(RegisterAdress & 0xFF);

			/* Pull CS low */
			HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_RESET);

			/* Send address */
			hal_ret = HAL_SPI_Transmit(p_platform->hspi, addr_buf, 2, VL53L8CX_COMM_TIMEOUT_MS);
			if (hal_ret != HAL_OK) {
				HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_SET);
				return (hal_ret == HAL_TIMEOUT) ? VL53L8CX_PLATFORM_TIMEOUT_ERROR : VL53L8CX_PLATFORM_STATUS_ERROR;
			}

			/* Send payload */
			hal_ret = HAL_SPI_Transmit(p_platform->hspi, p_values, (uint16_t)size, VL53L8CX_COMM_TIMEOUT_MS);

			/* Release CS */
			HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_SET);

			if (hal_ret == HAL_OK) return VL53L8CX_PLATFORM_OK;
			if (hal_ret == HAL_TIMEOUT) return VL53L8CX_PLATFORM_TIMEOUT_ERROR;
			return VL53L8CX_PLATFORM_STATUS_ERROR;
		
		#else
			return VL53L8CX_PLATFORM_INVALID_PARAM;
		#endif
		}

		default: return VL53L8CX_PLATFORM_INVALID_PARAM;
	}

}

/**
 * @brief Read multiple bytes from VL53L8CX sensor registers
 * 
 * This function reads multiple bytes from the specified register address of the
 * VL53L8CX sensor using either I2C or SPI communication based on the
 * platform configuration. The data is read sequentially starting from the
 * specified register address.
 * 
 * @param p_platform Pointer to VL53L8CX platform structure
 * @param RegisterAdress 16-bit starting register address to read from
 * @param p_values Pointer to buffer to store read bytes
 * @param size Number of bytes to read
 * @return uint8_t Status code (VL53L8CX_PLATFORM_OK on success)
 */
uint8_t VL53L8CX_RdMulti(VL53L8CX_Platform *p_platform, uint16_t RegisterAdress, uint8_t *p_values, uint32_t size) {

	/* Parameter validation */
	if (p_platform == NULL || p_values == NULL || size == 0) {
		return VL53L8CX_PLATFORM_INVALID_PARAM;
	}

	/* Select communication interface */
	switch (p_platform->comms_type) {
		case VL53L8CX_COMMS_I2C: {
		#if defined(HAL_I2C_MODULE_ENABLED)
		
			HAL_StatusTypeDef hal_ret = HAL_I2C_Mem_Read(p_platform->hi2c,
							 p_platform->i2c_addr,
							 RegisterAdress,
							 I2C_MEMADD_SIZE_16BIT,
							 p_values,
							 (uint16_t)size,
							 VL53L8CX_COMM_TIMEOUT_MS);

			if (hal_ret == HAL_OK) { return VL53L8CX_PLATFORM_OK; }
			else if (hal_ret == HAL_TIMEOUT) { return VL53L8CX_PLATFORM_TIMEOUT_ERROR; }
			else { return VL53L8CX_PLATFORM_STATUS_ERROR; }
		
		#else
			return VL53L8CX_PLATFORM_INVALID_PARAM;
		#endif
		}

		case VL53L8CX_COMMS_SPI: {
		#if defined(HAL_SPI_MODULE_ENABLED)
		
			HAL_StatusTypeDef hal_ret;
			if (p_platform->hspi == NULL || p_platform->cs_port == NULL) return VL53L8CX_PLATFORM_INVALID_PARAM;

			uint8_t addr_buf[2];
			addr_buf[0] = (uint8_t)((RegisterAdress >> 8) & 0xFF);
			addr_buf[1] = (uint8_t)(RegisterAdress & 0xFF);

			/* Pull CS low */
			HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_RESET);

			/* Send address */
			hal_ret = HAL_SPI_Transmit(p_platform->hspi, addr_buf, 2, VL53L8CX_COMM_TIMEOUT_MS);
			if (hal_ret != HAL_OK) {
				HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_SET);
				return (hal_ret == HAL_TIMEOUT) ? VL53L8CX_PLATFORM_TIMEOUT_ERROR : VL53L8CX_PLATFORM_STATUS_ERROR;
			}

			/* Receive payload */
			hal_ret = HAL_SPI_Receive(p_platform->hspi, p_values, (uint16_t)size, VL53L8CX_COMM_TIMEOUT_MS);

			/* Release CS */
			HAL_GPIO_WritePin(p_platform->cs_port, (uint16_t)p_platform->cs_pin, GPIO_PIN_SET);

			if (hal_ret == HAL_OK) return VL53L8CX_PLATFORM_OK;
			if (hal_ret == HAL_TIMEOUT) return VL53L8CX_PLATFORM_TIMEOUT_ERROR;
			return VL53L8CX_PLATFORM_STATUS_ERROR;
		
		#else
			return VL53L8CX_PLATFORM_INVALID_PARAM;
		#endif
		}

		default: return VL53L8CX_PLATFORM_INVALID_PARAM;
	}

}

/**
 * @brief Perform hardware reset of VL53L8CX sensor
 * 
 * This optional function performs a hardware reset of the VL53L8CX sensor
 * by toggling power pins. This function is not used internally by the API
 * but can be called by the host application when needed.
 * 
 * @note This is a template implementation that needs to be customized by
 *       the user based on their specific hardware design. The current
 *       implementation shows the sequence but does not actually control
 *       hardware pins.
 * 
 * @param p_platform Pointer to VL53L8CX platform structure
 * @return uint8_t Status code (always returns 0 in this template)
 */
uint8_t VL53L8CX_Reset_Sensor(VL53L8CX_Platform *p_platform) {
	uint8_t status = 0;
	
	/* (Optional) Need to be implemented by customer. This function returns 0 if OK */
	
	/* Set pin LPN to LOW */
	/* Set pin AVDD to LOW */
	/* Set pin VDDIO to LOW */
	/* Set pin CORE_1V8 to LOW */
	VL53L8CX_WaitMs(p_platform, 100);

	
	/* Set pin LPN to HIGH */
	/* Set pin AVDD to HIGH */
	/* Set pin VDDIO to HIGH */
	/* Set pin CORE_1V8 to HIGH */
	VL53L8CX_WaitMs(p_platform, 100);

	return status;
}

/**
 * @brief Swap byte order in a buffer (endianness conversion)
 * 
 * This function swaps the byte order of 32-bit words in a buffer. It is used
 * to convert between little-endian and big-endian formats. The buffer size
 * must be a multiple of 4 bytes.
 * 
 * @note This implementation processes the buffer in 4-byte chunks, swapping
 *       the byte order of each 32-bit word.
 * 
 * @param buffer Pointer to buffer containing data to swap
 * @param size Size of buffer in bytes (must be multiple of 4)
 */
void VL53L8CX_SwapBuffer(uint8_t *buffer, uint16_t size) {
	uint32_t i, tmp;
	
	/* Example of possible implementation using <string.h> */
	for(i = 0; i < size; i = i + 4) 
	{
		/* Combine 4 bytes into a 32-bit word with swapped order */
		tmp = (
		  buffer[i]<<24)
		|(buffer[i+1]<<16)
		|(buffer[i+2]<<8)
		|(buffer[i+3]);
		
		/* Copy the swapped word back to the buffer */
		memcpy(&(buffer[i]), &tmp, 4);
	}
}

/**
 * @brief Wait for specified milliseconds
 * 
 * This function implements a blocking delay for the specified number of
 * milliseconds. It uses the HAL_Delay function from the STM32 HAL library.
 * 
 * @note This function always returns 0 (success) as HAL_Delay does not
 *       provide error feedback.
 * 
 * @param p_platform Pointer to VL53L8CX platform structure (unused in this implementation)
 * @param TimeMs Number of milliseconds to wait
 * @return uint8_t Always returns 0 (VL53L8CX_PLATFORM_OK)
 */
uint8_t VL53L8CX_WaitMs(VL53L8CX_Platform *p_platform, uint32_t TimeMs) {
	HAL_Delay(TimeMs);
	return 0;
}
